The sources present differing views and nuances regarding the extent of syntax homogenization in database query languages between 2020 and 2025, particularly concerning the full breadth of SQL capabilities and the unification of graph query languages.
Disagreement 1: Extent of SQL Syntax Homogenization
Convergence is a Clear Trend The period from 2020 to 2025 has seen a significant move toward SQL syntax homogenization, driven by the latest SQL standards. SQL:2023 incorporated many functions (e.g., GREATEST, LEAST, ANY_VALUE) and native JSON support that were previously vendor-specific, essentially standardizing existing common practices and thereby enhancing portability across major relational databases. Many new distributed SQL/NewSQL databases (like CockroachDB and YugabyteDB) are opting for compatibility with established dialects such as PostgreSQL or MySQL instead of inventing new ones, which inherently fosters uniformity. Furthermore, modern application development increasingly favors widely supported SQL features and abstraction layers (ORMs) to avoid database lock-in, leading to a general decline in the use of idiosyncratic vendor-specific constructs. This collective effort has demonstrably improved year-over-year cross-engine query portability.
• Strongest Citations:
    ◦ " More broadly, vendor-specific SQL extensions appear to be receding in new development. Modern applications increasingly rely on widely supported SQL features and ORMs/abstraction layers to remain database-agnostic. As the SQL standard has incorporated formerly proprietary features... the need for custom syntax has declined... Cross-engine query portability has improved yearly..."
    ◦ " SQL:2023 Adoption: The latest SQL standard (approved June 2023) added property graph queries and standardized many functions long present in vendor dialects. Major databases are at varying stages of implementing these features. Many new functions (e.g. GREATEST/LEAST) were already in popular engines (Oracle, MySQL, Postgres) and are essentially “homogenized” by being standardized."
    ◦ " Furthermore, new database engines themselves often adopt the surface syntax of popular databases to lower the learning curve. For example, distributed SQL/NewSQL databases like CockroachDB or YugabyteDB claim compatibility with PostgreSQL’s dialect and drivers, effectively propagating Postgres’s quasi-standard syntax..."
Significant Variations Persist Despite the push for standardization, substantial vendor-specific differences in SQL persist, particularly in procedural languages and advanced functionalities. The ISO SQL/PSM standard for procedural SQL has not been widely adopted, meaning Oracle's PL/SQL, SQL Server's T-SQL, and PostgreSQL's PL/pgSQL remain distinct and incompatible, requiring significant rewriting for migration and showing little sign of convergence in new development. Moreover, cloud data warehouses and specialized databases continue to introduce proprietary extensions for advanced analytics or unique features, such as Google BigQuery's machine learning and geospatial SQL extensions or Snowflake's functions for semi-structured data, which create lock-in and impede portability for those specific use cases. No database is fully compliant with the latest SQL standards, leading developers to sometimes choose non-standard but convenient constructs (e.g., PostgreSQL's INSERT ... ON CONFLICT instead of standard MERGE), which perpetuates portability issues.
• Strongest Citations:
    ◦ " Stored Procedures and Procedural SQL Dialects: As noted, the ISO SQL/PSM standard for procedural language never gained full traction. Oracle’s PL/SQL, SQL Server’s T-SQL, and PostgreSQL’s PL/pgSQL remain quite different. A stored procedure written in PL/SQL will not run on SQL Server or Postgres without substantial rewriting, and vice versa. ... There’s little evidence of convergence here; if anything, each vendor extended their procedural language in recent versions..."
    ◦ " Vendor-Specific Analytics/Extensions: Cloud data warehouses, while SQL-based, do introduce new non-standard extensions in specialized areas. For instance: Google BigQuery has SQL extensions for machine learning (ML.PREDICT) and geospatial analysis (e.g., ST_GeogPoint), which are not part of ANSI SQL. ... Snowflake has proprietary functions for semi-structured data (like FLATTEN table function)..."
    ◦ " Lack of Universal Compliance: No database is fully compliant with SQL:2016 or SQL:2023. Each skips certain optional features or deviates. For example, PostgreSQL still hasn’t implemented the SQL standard MERGE... MySQL’s INSERT...ON DUPLICATE KEY UPDATE remains non-standard."
Disagreement 2: Graph Query Language Unification (ISO GQL)
GQL is Poised to Unify the Landscape The publication of ISO Graph Query Language (GQL) in April 2024 is seen as a landmark event, poised to unify the previously fragmented graph database landscape. GQL extensively builds on Neo4j's Cypher syntax, which was already a de facto standard, making it readily familiar to many users. Leading graph vendors, including Neo4j, TigerGraph, and AWS (for Neptune), have publicly committed to aligning with GQL, with Neo4j explicitly stating Cypher and GQL will converge. Early adopters like NebulaGraph have already announced native GQL support, demonstrating immediate industry uptake. This strong vendor alignment and common base are expected to significantly improve query portability among graph databases, lessening the need to choose between various dialects like Gremlin, Cypher, and PGQL.
• Strongest Citations:
    ◦ " ...the new ISO-standard Graph Query Language (GQL) (published 2024) has received broad industry support. Leading graph database vendors like Neo4j and TigerGraph have committed to aligning their query languages (e.g. Cypher) with GQL , signaling a convergence of syntax and semantics in the graph data domain. Even emerging open-source graph systems (NebulaGraph, etc.) rapidly implemented GQL."
    ◦ " Graph Query Language (ISO GQL): Published in April 2024, GQL is the first ISO database language since SQL. ... There is strong evidence of vendor alignment: Neo4j (with Cypher) and TigerGraph (with GSQL) have publicly committed to support ISO GQL. ... This industry consensus implies that, moving forward, query portability among graph databases will greatly improve."
    ◦ " ...Cypher and GQL have been on a deliberate convergence course, and that Neo4j’s Cypher will evolve to fully align with GQL over time. ... The takeaway is Neo4j is fully aligning with GQL, ensuring its massive user base will indirectly become GQL users."
Graph Query Adoption is Still in Transition Despite the introduction of ISO GQL, its adoption is still in a transitional phase as of 2025. Many existing applications continue to rely on established languages like Gremlin (especially with Apache TinkerPop/JanusGraph) and SPARQL (for RDF graphs), which are not yet aligned with GQL. Full industry adoption of GQL will require considerable time for vendors to implement the standard and for developers to migrate their existing skills and codebases. Furthermore, there is a potential for split adoption between GQL and SQL/PGQ (Property Graph Queries within SQL), as some vendors might favor one approach over the other, complicating the path to a truly unified graph querying landscape. Therefore, while the long-term trajectory points toward GQL's dominance, claims of it having already surpassed older languages may be premature, and portability issues persist in the short term.
• Strongest Citations:
    ◦ " Graph query adoption is still in transition: ISO GQL being brand new means many existing applications continue with Gremlin, Cypher, or SPARQL. Gremlin in particular remains entrenched in open-source graph stacks and some AWS Neptune customers. It will take time (and vendor implementations) for GQL to truly surpass all older languages."
    ◦ " Graph Query Languages – while we herald ISO GQL, as of 2025 it’s new. In practice, Gremlin (Apache TinkerPop) and SPARQL (for RDF graphs) remain in use and are not aligned with GQL. If your application used Gremlin traversals, you can’t just switch to GQL without a rewrite. Some graph DBs like JanusGraph, which use Gremlin, have not announced moves to GQL yet."
    ◦ " Also, GQL and SQL/PGQ are separate; some vendors might favor one approach over the other, causing some split in graph querying. For example, Oracle supports SQL/PGQ inside SQL, but Neo4j likely will support GQL as a standalone. Those two are intended to be compatible at some level (GQL and SQL/PGQ share concepts), but differences might emerge in how they’re used."